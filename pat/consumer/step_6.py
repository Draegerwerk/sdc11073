"""Tests operations."""

from __future__ import annotations

import decimal
import functools
import logging
import random
import string
import threading
import typing
import uuid

from pat.consumer import result_collector
from sdc11073.mdib import descriptorcontainers, statecontainers
from sdc11073.observableproperties import observables
from sdc11073.xml_types import msg_types, pm_qnames, pm_types

if typing.TYPE_CHECKING:
    from concurrent.futures import Future

    from sdc11073.consumer import SdcConsumer, operations
    from sdc11073.consumer.serviceclients import contextservice, setservice

__STEP__ = '6'
logger = logging.getLogger('pat.consumer')


def test_6b(consumer: SdcConsumer):  # noqa: C901
    """The Reference Consumer invokes SetContextState:
    - Payload: 1 patient context
    - Context state is added to the MDIB including context association and validation
    - If there is an associated context already, the Reference Provider disassociates that context
    - Handle and version information is generated by the Reference Provider
    - In order to avoid infinite growth of patient contexts, older contexts are allowed to be removed from the MDIB (when ContextAssociation is No)
    - The Reference Provider successfully concludes the invocation
    """  # noqa: D205, D400, D415, E501, W505
    set_context_state_handle = 'set_context_0.sco.mds_0'
    step = f'{__STEP__}b'
    operation_timeout = 5.0
    patient_context_update_timeout = 10.0

    patient_context_descriptors: list[descriptorcontainers.PatientContextDescriptorContainer] = (
        consumer.mdib.descriptions.NODETYPE.get(pm_qnames.PatientContextDescriptor, [])
    )
    if not patient_context_descriptors:
        result_collector.ResultCollector.log_failure(step=step, message='No patient descriptor found in mdib')
        return

    context_service: contextservice.ContextServiceClient = typing.cast(
        'contextservice.ContextServiceClient',
        consumer.context_service_client,
    )

    def _on_context_state(
        updates: dict[str, statecontainers.AbstractContextStateContainer],
        event: threading.Event,
        descriptor_handle: str,
        pat: statecontainers.PatientContextStateContainer,
    ):
        # state handle will be generated by provider
        for state in (s for s in updates.values() if s.DescriptorHandle == descriptor_handle):
            logger.debug(
                'received context state %s with the descriptor handle %s and context association %s',
                state.NODETYPE.localname,
                state.DescriptorHandle,
                state.ContextAssociation,
                extra={'step': step},
            )
            if state.ContextAssociation == association:
                if isinstance(state, statecontainers.PatientContextStateContainer):
                    if state.CoreData.Familyname == pat.CoreData.Familyname and not event.is_set():
                        event.set()

    for p in patient_context_descriptors:
        for association in list(pm_types.ContextAssociation):
            pat: statecontainers.PatientContextStateContainer = typing.cast(
                'statecontainers.PatientContextStateContainer',
                context_service.mk_proposed_context_object(p.Handle),
            )
            pat.CoreData.Familyname = uuid.uuid4().hex
            pat.ContextAssociation = association
            logger.info(
                'Set patient context with the descriptor handle "%s" to context association %s with family name %s',
                p.Handle,
                association,
                pat.CoreData.Familyname,
                extra={'step': step},
            )
            event = threading.Event()
            observer = functools.partial(_on_context_state, event=event, descriptor_handle=p.Handle, pat=pat)
            with observables.bound_context(consumer.mdib, context_by_handle=observer):
                fut: Future[operations.OperationResult] = context_service.set_context_state(
                    set_context_state_handle,
                    [pat],
                )
                try:
                    operation_result = fut.result(operation_timeout)
                except TimeoutError:
                    result_collector.ResultCollector.log_failure(
                        step=step,
                        message=f'SetContextState operation not finished within the timeout of {operation_timeout} '
                        f'seconds',
                    )
                    continue
                if operation_result.InvocationInfo.InvocationState not in (msg_types.InvocationState.FINISHED, msg_types.InvocationState.FINISHED_MOD):
                    result_collector.ResultCollector.log_failure(
                        step=step,
                        message=f'SetContextState operation failed with the following error '
                        f'{operation_result.InvocationInfo.InvocationError}: '
                        f'{operation_result.InvocationInfo.InvocationErrorMessage}',
                    )
                    continue

                if event.wait(patient_context_update_timeout):
                    result_collector.ResultCollector.log_success(
                        step=step,
                        message=f'Patient context "{pat.CoreData.Familyname}" with association {association} was '
                        f'successfully added to the MDIB',
                    )
                else:
                    result_collector.ResultCollector.log_failure(
                        step=step,
                        message=f'Patient context "{pat.CoreData.Familyname}" with association {association} was not '
                        f'added to the MDIB within the timeout of {patient_context_update_timeout} seconds',
                    )


def test_6c(consumer: SdcConsumer):
    """The Reference Consumer invokes SetValue:
    - The Reference Provider immediately responds with Fin
    - The Reference Provider sends Fin as a report in addition to the response
    """  # noqa: D205, D400, D415
    step = f'{__STEP__}c'
    operation_timeout = 5.0
    set_service: setservice.SetServiceClient = typing.cast('setservice.SetServiceClient', consumer.set_service_client)

    operations_ = consumer.mdib.descriptions.NODETYPE.get(pm_qnames.SetValueOperationDescriptor)
    if not operations_:
        result_collector.ResultCollector.log_failure(
            step=step,
            message='The reference provider provides no set value operations',
        )
    for operation in operations_:
        fut: Future[operations.OperationResult] = set_service.set_numeric_value(operation.Handle, decimal.Decimal(42))
        try:
            operation_result = fut.result(operation_timeout)
        except TimeoutError:
            result_collector.ResultCollector.log_failure(
                step=step,
                message=f'SetNumericValue operation not finished within the timeout of {operation_timeout} seconds',
            )
            continue
        if len(operation_result.report_parts) == 0:
            result_collector.ResultCollector.log_failure(
                step=step,
                message='SetNumericValue operation finished with 0 report parts, but expected exactly 1',
            )
        elif len(operation_result.report_parts) > 1:
            result_collector.ResultCollector.log_failure(
                step=step,
                message=f'SetNumericValue operation finished with {len(operation_result.report_parts)} report parts, '
                f'but expected exactly 1',
            )

        if operation_result.InvocationInfo.InvocationState in (
            msg_types.InvocationState.FINISHED,
            msg_types.InvocationState.FINISHED_MOD,
        ):
            result_collector.ResultCollector.log_success(
                step=step,
                message='SetNumericValue operation finished immediately responds with Fin',
            )
        else:
            result_collector.ResultCollector.log_failure(
                step=step,
                message=f'SetNumericValue operation failed with invocation state '
                f'{operation_result.InvocationInfo.InvocationState} and error '
                f'{operation_result.InvocationInfo.InvocationError}: '
                f'{operation_result.InvocationInfo.InvocationErrorMessage}',
            )


def test_6d(consumer: SdcConsumer):
    """The Reference Consumer invokes SetString:
    - The Reference Provider initiates a transaction that sends Wait, Start and Fin
    """  # noqa: D205, D400, D415
    step = f'{__STEP__}d'
    operation_timeout = 5.0
    expected_order = [
        msg_types.InvocationState.WAIT,
        msg_types.InvocationState.START,
        msg_types.InvocationState.FINISHED,
    ]
    set_service: setservice.SetServiceClient = typing.cast('setservice.SetServiceClient', consumer.set_service_client)

    operations_ = consumer.mdib.descriptions.NODETYPE.get(pm_qnames.SetStringOperationDescriptor)
    if not operations_:
        result_collector.ResultCollector.log_failure(
            step=step,
            message='The reference provider provides no set value operations',
        )

    for operation in operations_:
        fut: Future[operations.OperationResult] = set_service.set_string(operation.Handle, uuid.uuid4().hex)
        try:
            operation_result = fut.result(operation_timeout)
        except TimeoutError:
            result_collector.ResultCollector.log_failure(
                step=step,
                message=f'SetString operation not finished within the timeout of {operation_timeout} seconds',
            )
            continue
        if len(operation_result.report_parts) != len(expected_order):
            result_collector.ResultCollector.log_failure(
                step=step,
                message=f'SetString operation finished with {len(operation_result.report_parts)} report parts, '
                f'but expected exactly {len(expected_order)}',
            )
            continue
        for expected, actual in zip(
            expected_order,
            (p.InvocationInfo.InvocationState for p in operation_result.report_parts),
            strict=True,
        ):
            if expected == actual:
                result_collector.ResultCollector.log_success(
                    step=step,
                    message=f'The answer of SetString operation is "{expected}" as expected',
                )
            else:
                result_collector.ResultCollector.log_failure(
                    step=step,
                    message=f'The answer of SetString operation is "{actual}", but expected "{expected}"',
                )


def test_6e(consumer: SdcConsumer):  # noqa: C901, PLR0912
    """The Reference Consumer invokes SetMetricStates:
    - Payload: 2 metric states (settings; consider alert limits)
    - The Reference Provider immediately responds with Fin
    - Action: The Reference Provider alters values of given metrics
    """  # noqa: D205, D400, D415
    step = f'{__STEP__}e'
    operation_timeout = 5.0
    metric_state_counts = 2

    set_service: setservice.SetServiceClient = typing.cast('setservice.SetServiceClient', consumer.set_service_client)

    operations_ = consumer.mdib.descriptions.NODETYPE.get(pm_qnames.SetMetricStateOperationDescriptor)
    if not operations_:
        result_collector.ResultCollector.log_failure(
            step=step,
            message='The reference provider provides no set value operations',
        )

    metric_settings = [
        m
        for m in consumer.mdib.descriptions.objects
        if m.is_metric_descriptor and m.MetricCategory == pm_types.MetricCategory.SETTING
    ]
    if not metric_settings or len(metric_settings) < metric_state_counts:
        result_collector.ResultCollector.log_failure(
            step=step,
            message=f'The reference provider does not provide at least {metric_state_counts} metrics with '
            f'@MetricCategory="{pm_types.MetricCategory.SETTING}", but found {len(metric_settings)}',
        )
    for operation in operations_:
        metrics = random.sample(metric_settings, metric_state_counts)
        proposed_states = [consumer.mdib.xtra.mk_proposed_state(m.Handle) for m in metrics]
        for proposed_state in proposed_states:
            if proposed_state.MetricValue is None:
                proposed_state.mk_metric_value()
            if pm_qnames.EnumStringMetricState == proposed_state.NODETYPE:
                descriptor: descriptorcontainers.EnumStringMetricDescriptorContainer = (
                    consumer.mdib.descriptions.handle.get_one(proposed_state.DescriptorHandle)
                )
                allowed_values = {value.Value for value in descriptor.AllowedValue}
                proposed_state.MetricValue.Value = random.choice(
                    list(allowed_values - {proposed_state.MetricValue.Value}),
                )
            elif pm_qnames.StringMetricState == proposed_state.NODETYPE:
                proposed_state.MetricValue.Value = ''.join(random.choice(string.ascii_letters) for _ in range(10))
            elif pm_qnames.NumericMetricState == proposed_state.NODETYPE:
                proposed_state.MetricValue.Value = decimal.Decimal(str(random.random()))
            else:
                raise NotImplementedError(proposed_state.NODETYPE)
        fut: Future[operations.OperationResult] = set_service.set_metric_state(operation.Handle, proposed_states)
        try:
            operation_result = fut.result(operation_timeout)
        except TimeoutError:
            result_collector.ResultCollector.log_failure(
                step=step,
                message=f'SetMetricState operation not finished within the timeout of {operation_timeout} seconds',
            )
            continue
        if len(operation_result.report_parts) != 1:
            result_collector.ResultCollector.log_failure(
                step=step,
                message=f'SetString operation finished with {len(operation_result.report_parts)} report parts, but '
                f'expected exactly 1',
            )
            continue
        if operation_result.InvocationInfo.InvocationState in (
            msg_types.InvocationState.FINISHED,
            msg_types.InvocationState.FINISHED_MOD,
        ):
            result_collector.ResultCollector.log_success(
                step=step,
                message='SetMetricState operation finished immediately responds with Fin',
            )
        else:
            result_collector.ResultCollector.log_failure(
                step=step,
                message=f'SetMetricState operation failed with invocation state '
                f'{operation_result.InvocationInfo.InvocationState} and error '
                f'{operation_result.InvocationInfo.InvocationError}: '
                f'{operation_result.InvocationInfo.InvocationErrorMessage}',
            )


def test_6f(consumer: SdcConsumer):
    """The Reference Provider invokes Activate:
    - Payload: 3 arguments
    - The Reference Provider immediately responds with Fin
    - Action: The Reference Provider accepts 3 arguments, concatenates them and writes them to the operation target's metric value
    """  # noqa: D205, D400, D415, E501, W505
    step = f'{__STEP__}f'
    operation_timeout = 5.0

    # TODO: iterate over operations  # noqa: FIX002, TD002, TD003
    string_argument = msg_types.Argument()
    string_argument.ArgValue = ''.join(random.choice(string.ascii_lowercase) for i in range(20))
    decimal_argument = msg_types.Argument()
    decimal_argument.ArgValue = str(random.randint(1, 2**20))
    any_uri_argument = msg_types.Argument()
    any_uri_argument.ArgValue = f'urn:uuid:{uuid.uuid4()}'
    arguments = [string_argument, decimal_argument, any_uri_argument]
    activate_operation_handle = 'activate_1.sco.mds_0'
    try:
        activate_operation = consumer.mdib.get_entity(activate_operation_handle)
    except KeyError:
        result_collector.ResultCollector.log_failure(
            step=step,
            message=f'no operation with handle "{activate_operation_handle}" found in MDIB',
        )
        return
    expected_value = ''.join([argument.ArgValue for argument in arguments])
    observed = threading.Event()

    def _observe_operation_metric_value(metrics_by_handle: dict):
        if activate_operation.descriptor.OperationTarget in metrics_by_handle:
            state = metrics_by_handle[activate_operation.descriptor.OperationTarget]
            logger.debug(
                'received an update for "%s" with value "%s"',
                activate_operation.descriptor.OperationTarget,
                state.MetricValue,
                extra={'step': step},
            )
            if state.MetricValue is not None and state.MetricValue.Value == expected_value:
                observed.set()

    with observables.bound_context(consumer.mdib, metrics_by_handle=_observe_operation_metric_value):
        fut: Future = consumer.set_service_client.activate(activate_operation_handle, arguments)
        try:
            operation_result = fut.result(operation_timeout)
        except TimeoutError:
            result_collector.ResultCollector.log_failure(
                step=step,
                message=f'SetMetricState operation not finished within the timeout of {operation_timeout} seconds',
            )
            return
        if operation_result.InvocationInfo.InvocationState in (msg_types.InvocationState.FINISHED,):
            result_collector.ResultCollector.log_success(
                step=step,
                message=f'The metric with the handle "{activate_operation.descriptor.OperationTarget}" contains '
                f'{expected_value} as @MetricValue/@Value.',
            )
        else:
            result_collector.ResultCollector.log_failure(
                step=step,
                message=f'Activate operation failed with invocation state '
                f'{operation_result.InvocationInfo.InvocationState} and error '
                f'{operation_result.InvocationInfo.InvocationError}: '
                f'{operation_result.InvocationInfo.InvocationErrorMessage}',
            )
