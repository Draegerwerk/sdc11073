"""Tests operations."""

from __future__ import annotations

import decimal
import functools
import logging
import random
import string
import threading
import typing
import uuid

# result_collector removed; use logger and boolean returns instead
from sdc11073.mdib import descriptorcontainers, statecontainers
from sdc11073.observableproperties import observables
from sdc11073.xml_types import msg_types, pm_qnames, pm_types

if typing.TYPE_CHECKING:
    from collections.abc import Sequence
    from concurrent.futures import Future

    from sdc11073.consumer import SdcConsumer, operations
    from sdc11073.consumer.serviceclients import contextservice, setservice

__STEP__ = '6'
logger = logging.getLogger('pat.consumer')


def test_6b(consumer: SdcConsumer) -> bool:  # noqa: C901
    """The Reference Consumer invokes SetContextState:
    - Payload: 1 patient context
    - Context state is added to the MDIB including context association and validation
    - If there is an associated context already, the Reference Provider disassociates that context
    - Handle and version information is generated by the Reference Provider
    - In order to avoid infinite growth of patient contexts, older contexts are allowed to be removed from the MDIB (when ContextAssociation is No)
    - The Reference Provider successfully concludes the invocation
    """  # noqa: D205, D400, D415, E501, W505
    set_context_state_handle = 'set_context_0.sco.mds_0'
    step = f'{__STEP__}b'
    operation_timeout = 5.0
    patient_context_update_timeout = 10.0

    patient_context_descriptors: Sequence[descriptorcontainers.PatientContextDescriptorContainer] = (
        consumer.mdib.descriptions.NODETYPE.get(pm_qnames.PatientContextDescriptor, [])
    )
    if not patient_context_descriptors:
        logger.error('No patient descriptor found in mdib', extra={'step': step})
        return False

    context_service: contextservice.ContextServiceClient = typing.cast(
        'contextservice.ContextServiceClient',
        consumer.context_service_client,
    )

    def _on_context_state(
        updates: dict[str, statecontainers.AbstractContextStateContainer],
        event: threading.Event,
        descriptor_handle: str,
        pat: statecontainers.PatientContextStateContainer,
    ):
        # state handle will be generated by provider
        for state in (s for s in updates.values() if s.DescriptorHandle == descriptor_handle):
            logger.debug(
                'received context state %s with the descriptor handle %s and context association %s',
                state.NODETYPE.localname,
                state.DescriptorHandle,
                state.ContextAssociation,
                extra={'step': step},
            )
            if state.ContextAssociation == association:
                if isinstance(state, statecontainers.PatientContextStateContainer):
                    if state.CoreData.Familyname == pat.CoreData.Familyname and not event.is_set():
                        event.set()

    test_results: list[bool] = []
    for p in patient_context_descriptors:
        # set disassociated context is forbidden by 11073-10700 TR1638
        for association in [
            association
            for association in pm_types.ContextAssociation
            if association
            not in (pm_types.ContextAssociation.DISASSOCIATED, pm_types.ContextAssociation.NO_ASSOCIATION)
        ]:
            pat: statecontainers.PatientContextStateContainer = typing.cast(
                'statecontainers.PatientContextStateContainer',
                context_service.mk_proposed_context_object(p.Handle),
            )
            pat.CoreData.Familyname = uuid.uuid4().hex
            pat.ContextAssociation = association
            logger.debug(
                'Set patient context with the descriptor handle "%s" to context association %s with family name %s',
                p.Handle,
                association,
                pat.CoreData.Familyname,
                extra={'step': step},
            )
            event = threading.Event()
            observer = functools.partial(_on_context_state, event=event, descriptor_handle=p.Handle, pat=pat)
            with observables.bound_context(consumer.mdib, context_by_handle=observer):
                fut: Future[operations.OperationResult] = context_service.set_context_state(
                    set_context_state_handle,
                    [pat],
                )
                try:
                    operation_result = fut.result(operation_timeout)
                except TimeoutError:
                    logger.exception(
                        'The SetContextState operation with the handle %s not finished within the timeout of %s '
                        'seconds for association %s',
                        set_context_state_handle,
                        operation_timeout,
                        association,
                        extra={'step': step},
                    )
                    test_results.append(False)
                    continue
                if operation_result.InvocationInfo.InvocationState not in (
                    msg_types.InvocationState.FINISHED,
                    msg_types.InvocationState.FINISHED_MOD,
                ):
                    logger.error(
                        'The SetContextState operation with the handle %s failed for association %s with the '
                        'state %s and the error %s: %s',
                        set_context_state_handle,
                        association,
                        operation_result.InvocationInfo.InvocationState,
                        operation_result.InvocationInfo.InvocationError,
                        operation_result.InvocationInfo.InvocationErrorMessage,
                        extra={'step': step},
                    )
                    test_results.append(False)
                    continue

                if event.wait(patient_context_update_timeout):
                    logger.info(
                        'Patient context "%s" with association %s was successfully added to the MDIB',
                        pat.CoreData.Familyname,
                        association,
                        extra={'step': step},
                    )
                    test_results.append(True)
                else:
                    logger.error(
                        'Patient context "%s" with association %s was not added to the MDIB within the timeout '
                        'of %s seconds',
                        pat.CoreData.Familyname,
                        association,
                        patient_context_update_timeout,
                        extra={'step': step},
                    )
                    test_results.append(False)
    return any(test_results) and all(test_results)


def test_6c(consumer: SdcConsumer) -> bool:
    """The Reference Consumer invokes SetValue:
    - The Reference Provider immediately responds with Fin
    - The Reference Provider sends Fin as a report in addition to the response
    """  # noqa: D205, D400, D415
    step = f'{__STEP__}c'
    operation_timeout = 5.0
    set_service: setservice.SetServiceClient = typing.cast('setservice.SetServiceClient', consumer.set_service_client)

    operations_ = consumer.mdib.descriptions.NODETYPE.get(pm_qnames.SetValueOperationDescriptor)
    if not operations_:
        logger.error('The reference provider provides no set value operations', extra={'step': step})
        return False
    test_results: list[bool] = []
    for operation in operations_:
        fut: Future[operations.OperationResult] = set_service.set_numeric_value(operation.Handle, decimal.Decimal(42))
        try:
            operation_result = fut.result(operation_timeout)
        except TimeoutError:
            logger.exception(
                'SetNumericValue operation not finished within the timeout of %s seconds',
                operation_timeout,
                extra={'step': step},
            )
            test_results.append(False)
            continue
        if len(operation_result.report_parts) == 0:
            logger.error(
                'SetNumericValue operation finished with 0 report parts, but expected exactly 1',
                extra={'step': step},
            )
            test_results.append(False)
        elif len(operation_result.report_parts) > 1:
            logger.error(
                'SetNumericValue operation finished with %d report parts, but expected exactly 1',
                len(operation_result.report_parts),
                extra={'step': step},
            )
            test_results.append(False)

        if operation_result.InvocationInfo.InvocationState in (
            msg_types.InvocationState.FINISHED,
            msg_types.InvocationState.FINISHED_MOD,
        ):
            logger.info('SetNumericValue operation finished immediately responds with Fin', extra={'step': step})
            test_results.append(True)
        else:
            logger.error(
                'SetNumericValue operation failed with invocation state %s and error %s: %s',
                operation_result.InvocationInfo.InvocationState,
                operation_result.InvocationInfo.InvocationError,
                operation_result.InvocationInfo.InvocationErrorMessage,
                extra={'step': step},
            )
            test_results.append(False)
    return any(test_results) and all(test_results)


def test_6d(consumer: SdcConsumer) -> bool:
    """The Reference Consumer invokes SetString:
    - The Reference Provider initiates a transaction that sends Wait, Start and Fin
    """  # noqa: D205, D400, D415
    step = f'{__STEP__}d'
    operation_timeout = 5.0
    expected_order = [
        msg_types.InvocationState.WAIT,
        msg_types.InvocationState.START,
        msg_types.InvocationState.FINISHED,
    ]
    set_service: setservice.SetServiceClient = typing.cast('setservice.SetServiceClient', consumer.set_service_client)

    operations_: Sequence[descriptorcontainers.SetStringOperationDescriptorContainer] = (
        consumer.mdib.descriptions.NODETYPE.get(pm_qnames.SetStringOperationDescriptor, [])
    )
    if not operations_:
        logger.error('The reference provider provides no set value operations', extra={'step': step})
        return False

    test_results: list[bool] = []
    for operation in operations_:
        target = consumer.mdib.descriptions.handle.get_one(operation.OperationTarget)
        if not isinstance(target, descriptorcontainers.EnumStringMetricDescriptorContainer):
            msg = f'Expected {descriptorcontainers.EnumStringMetricDescriptorContainer}, but got {type(target)}'
            raise TypeError(msg)
        value_to_be_set = random.choice([allowed_value.Value for allowed_value in target.AllowedValue])
        fut: Future[operations.OperationResult] = set_service.set_string(operation.Handle, value_to_be_set)
        try:
            operation_result = fut.result(operation_timeout)
        except TimeoutError:
            logger.exception(
                'The SetString operation with the handle %s did not finish within the timeout of %s seconds',
                operation.Handle,
                operation_timeout,
                extra={'step': step},
            )
            test_results.append(False)
            continue
        if len(operation_result.report_parts) != len(expected_order):
            logger.error(
                'The SetString operation with the handle %s finished with %d report parts, but expected exactly %d',
                operation.Handle,
                len(operation_result.report_parts),
                len(expected_order),
                extra={'step': step},
            )
            test_results.append(False)
            continue
        for report in (
            report
            for report in operation_result.report_parts
            if report.InvocationInfo.InvocationState not in expected_order
        ):
            logger.error(
                'The SetString operation with the handle %s returned unexpected invocation state %s with error %s: %s',
                operation.Handle,
                report.InvocationInfo.InvocationState,
                report.InvocationInfo.InvocationError,
                report.InvocationInfo.InvocationErrorMessage,
                extra={'step': step},
            )
            test_results.append(False)
        for expected, actual in zip(
            expected_order,
            (p.InvocationInfo.InvocationState for p in operation_result.report_parts),
            strict=True,
        ):
            if expected == actual:
                logger.info(
                    'The answer of the SetString operation with the handle %s operation is "%s" as expected',
                    operation.Handle,
                    expected,
                    extra={'step': step},
                )
            else:
                logger.error(
                    'The answer of the SetString operation with the handle %s operation is "%s", but expected "%s"',
                    operation.Handle,
                    actual,
                    expected,
                    extra={'step': step},
                )
                test_results.append(False)
        if not any(
            expected == actual
            for expected, actual in zip(
                expected_order,
                (p.InvocationInfo.InvocationState for p in operation_result.report_parts),
                strict=True,
            )
        ):
            test_results.append(False)
        else:
            test_results.append(True)
    return any(test_results) and all(test_results)


def test_6e(consumer: SdcConsumer) -> bool:  # noqa: C901, PLR0912
    """The Reference Consumer invokes SetMetricStates:
    - Payload: 2 metric states (settings; consider alert limits)
    - The Reference Provider immediately responds with Fin
    - Action: The Reference Provider alters values of given metrics
    """  # noqa: D205, D400, D415
    step = f'{__STEP__}e'
    operation_timeout = 5.0
    metric_state_counts = 2

    set_service: setservice.SetServiceClient = typing.cast('setservice.SetServiceClient', consumer.set_service_client)

    operations_ = consumer.mdib.descriptions.NODETYPE.get(pm_qnames.SetMetricStateOperationDescriptor)
    if not operations_:
        logger.error('The reference provider provides no set value operations', extra={'step': step})
        return False

    metric_settings = [
        m
        for m in consumer.mdib.descriptions.objects
        if m.is_metric_descriptor and m.MetricCategory == pm_types.MetricCategory.SETTING
    ]
    if not metric_settings or len(metric_settings) < metric_state_counts:
        logger.error(
            'The reference provider does not provide at least %d metrics with @MetricCategory="%s", but found %d',
            metric_state_counts,
            pm_types.MetricCategory.SETTING,
            len(metric_settings),
            extra={'step': step},
        )
        return False
    test_results: list[bool] = []
    for operation in operations_:
        metrics = random.sample(metric_settings, metric_state_counts)
        proposed_states = [consumer.mdib.xtra.mk_proposed_state(m.Handle) for m in metrics]
        for proposed_state in proposed_states:
            if proposed_state.MetricValue is None:
                proposed_state.mk_metric_value()
            if pm_qnames.EnumStringMetricState == proposed_state.NODETYPE:
                descriptor: descriptorcontainers.EnumStringMetricDescriptorContainer = (
                    consumer.mdib.descriptions.handle.get_one(proposed_state.DescriptorHandle)
                )
                allowed_values = {value.Value for value in descriptor.AllowedValue}
                proposed_state.MetricValue.Value = random.choice(
                    list(allowed_values - {proposed_state.MetricValue.Value}),
                )
            elif pm_qnames.StringMetricState == proposed_state.NODETYPE:
                proposed_state.MetricValue.Value = ''.join(random.choice(string.ascii_letters) for _ in range(10))
            elif pm_qnames.NumericMetricState == proposed_state.NODETYPE:
                proposed_state.MetricValue.Value = decimal.Decimal(str(random.random()))
            else:
                raise NotImplementedError(proposed_state.NODETYPE)
        fut: Future[operations.OperationResult] = set_service.set_metric_state(operation.Handle, proposed_states)
        try:
            operation_result = fut.result(operation_timeout)
        except TimeoutError:
            logger.exception(
                'SetMetricState operation not finished within the timeout of %s seconds',
                operation_timeout,
                extra={'step': step},
            )
            test_results.append(False)
            continue
        if len(operation_result.report_parts) != 1:
            logger.error(
                'SetString operation finished with %d report parts, but expected exactly 1',
                len(operation_result.report_parts),
                extra={'step': step},
            )
            test_results.append(False)
            continue
        if operation_result.InvocationInfo.InvocationState in (
            msg_types.InvocationState.FINISHED,
            msg_types.InvocationState.FINISHED_MOD,
        ):
            logger.info('SetMetricState operation finished immediately responds with Fin', extra={'step': step})
            test_results.append(True)
        else:
            logger.error(
                'SetMetricState operation failed with invocation state %s and error %s: %s',
                operation_result.InvocationInfo.InvocationState,
                operation_result.InvocationInfo.InvocationError,
                operation_result.InvocationInfo.InvocationErrorMessage,
                extra={'step': step},
            )
            test_results.append(False)
    return any(test_results) and all(test_results)


def test_6f(consumer: SdcConsumer) -> bool:
    """The Reference Provider invokes Activate:
    - Payload: 3 arguments
    - The Reference Provider immediately responds with Fin
    - Action: The Reference Provider accepts 3 arguments, concatenates them and writes them to the operation target's metric value
    """  # noqa: D205, D400, D415, E501, W505
    step = f'{__STEP__}f'
    operation_timeout = 5.0

    # TODO: iterate over operations  # noqa: FIX002, TD002, TD003
    string_argument = msg_types.Argument()
    string_argument.ArgValue = ''.join(random.choice(string.ascii_lowercase) for i in range(20))
    decimal_argument = msg_types.Argument()
    decimal_argument.ArgValue = str(random.randint(1, 2**20))
    any_uri_argument = msg_types.Argument()
    any_uri_argument.ArgValue = f'urn:uuid:{uuid.uuid4()}'
    arguments = [string_argument, decimal_argument, any_uri_argument]
    activate_operation_handle = 'activate_1.sco.mds_0'
    try:
        activate_operation = consumer.mdib.get_entity(activate_operation_handle)
    except KeyError:
        logger.error(  # noqa: TRY400
            'no operation with handle "%s" found in MDIB',
            activate_operation_handle,
            extra={'step': step},
        )
        return False
    expected_value = ''.join([argument.ArgValue for argument in arguments])
    observed = threading.Event()

    def _observe_operation_metric_value(metrics_by_handle: dict):
        if activate_operation.descriptor.OperationTarget in metrics_by_handle:
            state = metrics_by_handle[activate_operation.descriptor.OperationTarget]
            logger.debug(
                'received an update for "%s" with value "%s"',
                activate_operation.descriptor.OperationTarget,
                state.MetricValue,
                extra={'step': step},
            )
            if state.MetricValue is not None and state.MetricValue.Value == expected_value:
                observed.set()

    with observables.bound_context(consumer.mdib, metrics_by_handle=_observe_operation_metric_value):
        fut: Future = consumer.set_service_client.activate(activate_operation_handle, arguments)
        try:
            operation_result = fut.result(operation_timeout)
        except TimeoutError:
            logger.exception(
                'SetMetricState operation not finished within the timeout of %s seconds',
                operation_timeout,
                extra={'step': step},
            )
            return False
        if operation_result.InvocationInfo.InvocationState in (msg_types.InvocationState.FINISHED,):
            logger.info(
                'The metric with the handle %s contains %s as @MetricValue/@Value.',
                activate_operation.descriptor.OperationTarget,
                expected_value,
                extra={'step': step},
            )
            return True
        logger.error(
            'Activate operation failed with invocation state %s and error %s: %s',
            operation_result.InvocationInfo.InvocationState,
            operation_result.InvocationInfo.InvocationError,
            operation_result.InvocationInfo.InvocationErrorMessage,
            extra={'step': step},
        )
        return False
