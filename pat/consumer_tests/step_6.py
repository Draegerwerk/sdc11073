"""Tests operations."""

from __future__ import annotations

import decimal
import functools
import logging
import random
import string
import threading
import time
import typing
import uuid

# result_collector removed; use logger and boolean returns instead
from sdc11073.mdib import descriptorcontainers, statecontainers
from sdc11073.observableproperties import observables
from sdc11073.xml_types import msg_types, pm_qnames, pm_types

if typing.TYPE_CHECKING:
    from collections.abc import Sequence
    from concurrent.futures import Future

    from sdc11073.consumer import SdcConsumer, operations
    from sdc11073.consumer.serviceclients import contextservice, setservice

__STEP__ = '6'
logger = logging.getLogger('pat.consumer')


def test_6b(consumer: SdcConsumer) -> bool:  # noqa: C901
    """The Reference Consumer invokes SetContextState:
    - Payload: 1 patient context
    - Context state is added to the MDIB including context association and validation
    - If there is an associated context already, the Reference Provider disassociates that context
    - Handle and version information is generated by the Reference Provider
    - In order to avoid infinite growth of patient contexts, older contexts are allowed to be removed from the MDIB (when ContextAssociation is No)
    - The Reference Provider successfully concludes the invocation
    """  # noqa: D205, D400, D415, E501, W505
    set_context_state: descriptorcontainers.SetContextStateOperationDescriptorContainer = (
        consumer.mdib.descriptions.handle.get_one('set_context_0.sco.mds_0')
    )
    step = f'{__STEP__}b'
    patient_context_update_timeout = 10.0

    patient_context_descriptors: Sequence[descriptorcontainers.PatientContextDescriptorContainer] = (
        consumer.mdib.descriptions.NODETYPE.get(pm_qnames.PatientContextDescriptor, [])
    )
    if not patient_context_descriptors:
        logger.error('No patient descriptor found in mdib', extra={'step': step})
        return False

    context_service: contextservice.ContextServiceClient = typing.cast(
        'contextservice.ContextServiceClient',
        consumer.context_service_client,
    )

    def _on_context_state(
        updates: dict[str, statecontainers.AbstractContextStateContainer],
        event: threading.Event,
        descriptor_handle: str,
        pat: statecontainers.PatientContextStateContainer,
        association_to_listen: pm_types.ContextAssociation,
    ):
        # state handle will be generated by provider
        for state in (s for s in updates.values() if s.DescriptorHandle == descriptor_handle):
            logger.debug(
                'received context state %s with the descriptor handle %s and context association %s',
                state.NODETYPE.localname,
                state.DescriptorHandle,
                state.ContextAssociation,
                extra={'step': step},
            )
            if state.ContextAssociation == association_to_listen:
                if isinstance(state, statecontainers.PatientContextStateContainer):
                    if state.CoreData.Familyname == pat.CoreData.Familyname:
                        event.set()

    test_results: list[bool] = []
    for p in patient_context_descriptors:
        for association in [
            association
            for association in pm_types.ContextAssociation
            if association
            not in (pm_types.ContextAssociation.DISASSOCIATED, pm_types.ContextAssociation.NO_ASSOCIATION)
        ]:
            pat: statecontainers.PatientContextStateContainer = typing.cast(
                'statecontainers.PatientContextStateContainer',
                context_service.mk_proposed_context_object(p.Handle),
            )
            pat.CoreData.Familyname = uuid.uuid4().hex
            pat.ContextAssociation = association
            logger.debug(
                'Set patient context with the descriptor handle "%s" to context association %s with family name %s',
                p.Handle,
                association,
                pat.CoreData.Familyname,
                extra={'step': step},
            )
            event = threading.Event()
            observer = functools.partial(
                _on_context_state,
                event=event,
                descriptor_handle=p.Handle,
                pat=pat,
                association_to_listen=association,
            )
            if set_context_state.MaxTimeToFinish is None:
                timeout = 10.0
                logger.warning(
                    'SetMetricState operation with the handle %s has no MaxTimeToFinish, using default of %d seconds',
                    set_context_state.Handle,
                    timeout,
                    extra={'step': step},
                )
            else:
                timeout = set_context_state.MaxTimeToFinish
            with observables.bound_context(consumer.mdib, context_by_handle=observer):
                fut: Future[operations.OperationResult] = context_service.set_context_state(
                    set_context_state.Handle,
                    [pat],
                )
                try:
                    operation_result = fut.result(timeout)
                except TimeoutError:
                    logger.exception(
                        'The SetContextState operation with the handle %s not finished within the timeout of %s '
                        'seconds for association %s',
                        set_context_state.Handle,
                        timeout,
                        association,
                        extra={'step': step},
                    )
                    test_results.append(False)
                    continue
                if operation_result.InvocationInfo.InvocationState not in (
                    msg_types.InvocationState.FINISHED,
                    msg_types.InvocationState.FINISHED_MOD,
                ):
                    logger.error(
                        'The SetContextState operation with the handle %s failed for association %s with the '
                        'state %s and the error %s: %s',
                        set_context_state.Handle,
                        association,
                        operation_result.InvocationInfo.InvocationState,
                        operation_result.InvocationInfo.InvocationError,
                        operation_result.InvocationInfo.InvocationErrorMessage,
                        extra={'step': step},
                    )
                    test_results.append(False)
                    continue

                if event.wait(patient_context_update_timeout):
                    logger.info(
                        'Patient context "%s" with association %s was successfully added to the MDIB',
                        pat.CoreData.Familyname,
                        association,
                        extra={'step': step},
                    )
                    test_results.append(True)
                else:
                    logger.error(
                        'Patient context "%s" with association %s was not added to the MDIB within the timeout '
                        'of %s seconds',
                        pat.CoreData.Familyname,
                        association,
                        patient_context_update_timeout,
                        extra={'step': step},
                    )
                    test_results.append(False)
    return any(test_results) and all(test_results)


def test_6c(consumer: SdcConsumer) -> bool:
    """The Reference Consumer invokes SetValue:
    - The Reference Provider immediately responds with Fin
    - The Reference Provider sends Fin as a report in addition to the response
    """  # noqa: D205, D400, D415
    step = f'{__STEP__}c'
    set_service: setservice.SetServiceClient = typing.cast('setservice.SetServiceClient', consumer.set_service_client)

    operations_: Sequence[descriptorcontainers.SetValueOperationDescriptorContainer] = (
        consumer.mdib.descriptions.NODETYPE.get(pm_qnames.SetValueOperationDescriptor)
    )
    if not operations_:
        logger.error('The reference provider provides no set value operations', extra={'step': step})
        return False
    test_results: list[bool] = []
    for operation in operations_:
        state: statecontainers.SetValueOperationStateContainer = consumer.mdib.states.descriptor_handle.get_one(
            operation.Handle,
        )
        if len(state.AllowedRange) == 0:
            value = random.randint(1, 10000)
        else:
            value = random.choice([state.AllowedRange[0].Lower, state.AllowedRange[0].Upper])
        fut: Future[operations.OperationResult] = set_service.set_numeric_value(
            operation.Handle,
            value,
        )
        if operation.MaxTimeToFinish is None:
            timeout = 10.0
            logger.warning(
                'SetMetricState operation with the handle %s has no MaxTimeToFinish, using default of %d seconds',
                operation.Handle,
                timeout,
                extra={'step': step},
            )
        else:
            timeout = operation.MaxTimeToFinish
        try:
            operation_result = fut.result(timeout)
        except TimeoutError:
            logger.exception(
                'SetNumericValue operation not finished within the timeout of %s seconds',
                timeout,
                extra={'step': step},
            )
            test_results.append(False)
            continue
        if operation_result.set_response.InvocationInfo.InvocationState != msg_types.InvocationState.FINISHED:
            logger.error(
                'SetNumericValue operation not immediately responded with %s but with invocation state '
                '%s and error %s: %s',
                msg_types.InvocationState.FINISHED,
                operation_result.set_response.InvocationInfo.InvocationState,
                operation_result.set_response.InvocationInfo.InvocationError,
                operation_result.set_response.InvocationInfo.InvocationErrorMessage,
                extra={'step': step},
            )
            test_results.append(False)
        else:
            logger.info(
                'SetNumericValue operation immediately responded with %s as expected',
                msg_types.InvocationState.FINISHED,
                extra={'step': step},
            )
            test_results.append(True)
        if len(operation_result.report_parts) != 1:
            logger.error(
                'SetNumericValue operation finished with %d report parts, but expected exactly 1',
                len(operation_result.report_parts),
                extra={'step': step},
            )
            test_results.append(False)

        if operation_result.InvocationInfo.InvocationState == msg_types.InvocationState.FINISHED:
            logger.info('OperationInvokedReport contains invocation info Fin', extra={'step': step})
            test_results.append(True)
        else:
            logger.error(
                'SetNumericValue operation failed with invocation state %s and error %s: %s',
                operation_result.InvocationInfo.InvocationState,
                operation_result.InvocationInfo.InvocationError,
                operation_result.InvocationInfo.InvocationErrorMessage,
                extra={'step': step},
            )
            test_results.append(False)
    return any(test_results) and all(test_results)


def test_6d(consumer: SdcConsumer) -> bool:  # noqa: C901, PLR0912
    """The Reference Consumer invokes SetString:
    - The Reference Provider initiates a transaction that sends Wait, Start and Fin
    """  # noqa: D205, D400, D415
    step = f'{__STEP__}d'
    expected_order = [
        msg_types.InvocationState.WAIT,
        msg_types.InvocationState.START,
        msg_types.InvocationState.FINISHED,
    ]
    set_service: setservice.SetServiceClient = typing.cast('setservice.SetServiceClient', consumer.set_service_client)

    operations_: Sequence[descriptorcontainers.SetStringOperationDescriptorContainer] = (
        consumer.mdib.descriptions.NODETYPE.get(pm_qnames.SetStringOperationDescriptor, [])
    )
    if not operations_:
        logger.error('The reference provider provides no set string operations', extra={'step': step})
        return False

    test_results: list[bool] = []
    for operation in operations_:
        target = consumer.mdib.descriptions.handle.get_one(operation.OperationTarget)
        if not isinstance(target, descriptorcontainers.EnumStringMetricDescriptorContainer):
            msg = f'Expected {descriptorcontainers.EnumStringMetricDescriptorContainer}, but got {type(target)}'
            raise TypeError(msg)
        set_string_operation_state: statecontainers.SetStringOperationStateContainer = (
            consumer.mdib.states.descriptor_handle.get_one(operation.Handle)
        )
        if len(set_string_operation_state.AllowedValues.Value) > 0:
            value_to_be_set = random.choice(set_string_operation_state.AllowedValues.Value)
        else:
            value_to_be_set = random.choice([allowed_value.Value for allowed_value in target.AllowedValue])

        if operation.MaxTimeToFinish is None:
            timeout = 10.0
            logger.warning(
                'SetMetricState operation with the handle %s has no MaxTimeToFinish, using default of %d seconds',
                operation.Handle,
                timeout,
                extra={'step': step},
            )
        else:
            timeout = operation.MaxTimeToFinish
        fut: Future[operations.OperationResult] = set_service.set_string(operation.Handle, value_to_be_set)
        try:
            operation_result = fut.result(timeout)
        except TimeoutError:
            logger.exception(
                'The SetString operation with the handle %s did not finish within the timeout of %s seconds',
                operation.Handle,
                timeout,
                extra={'step': step},
            )
            test_results.append(False)
            continue
        if operation_result.set_response.InvocationInfo.InvocationState != msg_types.InvocationState.WAIT:
            logger.error(
                'SetString operation not responded with %s but with %s',
                msg_types.InvocationState.WAIT,
                operation_result.set_response.InvocationInfo.InvocationState,
                extra={'step': step},
            )
            test_results.append(False)
        else:
            logger.info(
                'SetString operation responded with %s as expected',
                msg_types.InvocationState.WAIT,
                extra={'step': step},
            )
            test_results.append(True)
        if len(operation_result.report_parts) != len(expected_order):
            logger.error(
                'The SetString operation with the handle %s finished with %d report parts, but expected exactly %d',
                operation.Handle,
                len(operation_result.report_parts),
                len(expected_order),
                extra={'step': step},
            )
            test_results.append(False)
            continue
        for report in (
            report
            for report in operation_result.report_parts
            if report.InvocationInfo.InvocationState not in expected_order
        ):
            logger.error(
                'The SetString operation with the handle %s returned unexpected invocation state %s with error %s: %s',
                operation.Handle,
                report.InvocationInfo.InvocationState,
                report.InvocationInfo.InvocationError,
                report.InvocationInfo.InvocationErrorMessage,
                extra={'step': step},
            )
            test_results.append(False)
        for expected, actual in zip(
            expected_order,
            (p.InvocationInfo.InvocationState for p in operation_result.report_parts),
            strict=True,
        ):
            if expected == actual:
                logger.info(
                    'The answer of the SetString operation with the handle %s operation is "%s" as expected',
                    operation.Handle,
                    expected,
                    extra={'step': step},
                )
                test_results.append(True)
            else:
                logger.error(
                    'The answer of the SetString operation with the handle %s operation is "%s", but expected "%s"',
                    operation.Handle,
                    actual,
                    expected,
                    extra={'step': step},
                )
                test_results.append(False)
    return any(test_results) and all(test_results)


def _observe_metric_value_change(
    expected_values_by_handle: dict[str, typing.Any],
    observed_handles: set[str],
    completion_event: threading.Event,
    step: str,
) -> typing.Callable[[dict[str, statecontainers.AbstractMetricStateContainer]], None]:
    """Return an observer that marks when all expected metric values were reported."""
    expected_handles = set(expected_values_by_handle)

    def _observer(metrics_by_handle: dict[str, statecontainers.AbstractMetricStateContainer]) -> None:
        if completion_event.is_set():
            return
        for descriptor_handle, state in metrics_by_handle.items():
            if descriptor_handle not in expected_handles:
                continue
            metric_value = state.MetricValue.Value if state.MetricValue is not None else None
            expected_value = expected_values_by_handle[descriptor_handle]
            logger.debug(
                'received metric update for "%s" with value "%s" (expected "%s")',
                descriptor_handle,
                metric_value,
                expected_value,
                extra={'step': step},
            )
            if metric_value != expected_value:
                continue
            observed_handles.add(descriptor_handle)
            if expected_handles.issubset(observed_handles):
                logger.info(
                    'All metric updates observed for handles %s',
                    sorted(expected_handles),
                    extra={'step': step},
                )
                completion_event.set()

    return _observer


def _propose_states(
    metric_settings: Sequence[descriptorcontainers.AbstractMetricDescriptorContainer],
    metric_state_counts: int,
    consumer: SdcConsumer,
) -> Sequence[
    statecontainers.NumericMetricStateContainer
    | statecontainers.EnumStringMetricStateContainer
    | statecontainers.StringMetricStateContainer
]:
    metrics = random.sample(metric_settings, metric_state_counts)
    proposed_states = [consumer.mdib.xtra.mk_proposed_state(m.Handle) for m in metrics]

    for proposed_state in proposed_states:
        if proposed_state.MetricValue is None:
            proposed_state.mk_metric_value()
        if pm_qnames.EnumStringMetricState == proposed_state.NODETYPE:
            descriptor: descriptorcontainers.EnumStringMetricDescriptorContainer = (
                consumer.mdib.descriptions.handle.get_one(proposed_state.DescriptorHandle)
            )
            allowed_values = {value.Value for value in descriptor.AllowedValue}
            proposed_state.MetricValue.Value = random.choice(
                list(allowed_values - {proposed_state.MetricValue.Value}),
            )
        elif pm_qnames.StringMetricState == proposed_state.NODETYPE:
            proposed_state.MetricValue.Value = ''.join(random.choice(string.ascii_letters) for _ in range(10))
        elif pm_qnames.NumericMetricState == proposed_state.NODETYPE:
            # only 5 decimal places because of float conversion error
            proposed_state.MetricValue.Value = decimal.Decimal(f"{random.uniform(0, 100):.2f}")
        else:
            raise NotImplementedError(proposed_state.NODETYPE)
    return proposed_states


def test_6e(consumer: SdcConsumer) -> bool:  # noqa: PLR0915
    """The Reference Consumer invokes SetMetricStates:
    - Payload: 2 metric states (settings; consider alert limits)
    - The Reference Provider immediately responds with Fin
    - Action: The Reference Provider alters values of given metrics
    """  # noqa: D205, D400, D415
    step = f'{__STEP__}e'
    metric_state_counts = 2

    set_service: setservice.SetServiceClient = typing.cast('setservice.SetServiceClient', consumer.set_service_client)

    operations_: Sequence[descriptorcontainers.SetMetricStateOperationDescriptorContainer] = (
        consumer.mdib.descriptions.NODETYPE.get(pm_qnames.SetMetricStateOperationDescriptor)
    )
    if not operations_:
        logger.error('The reference provider provides no set metric state operations', extra={'step': step})
        return False

    metric_settings = [
        m
        for m in consumer.mdib.descriptions.objects
        if m.is_metric_descriptor and m.MetricCategory == pm_types.MetricCategory.SETTING
    ]
    if not metric_settings or len(metric_settings) < metric_state_counts:
        logger.error(
            'The reference provider does not provide at least %d metrics with @MetricCategory="%s", but found %d',
            metric_state_counts,
            pm_types.MetricCategory.SETTING,
            len(metric_settings),
            extra={'step': step},
        )
        return False
    test_results: list[bool] = []
    for operation in operations_:
        proposed_states = _propose_states(metric_settings, metric_state_counts, consumer)
        expected_values_by_handle = {
            proposed_state.DescriptorHandle: proposed_state.MetricValue.Value for proposed_state in proposed_states
        }

        observer_event = threading.Event()
        observed_handles: set[str] = set()
        observer = _observe_metric_value_change(
            expected_values_by_handle=expected_values_by_handle,
            observed_handles=observed_handles,
            completion_event=observer_event,
            step=step,
        )
        metrics_updated = False
        if operation.MaxTimeToFinish is None:
            timeout = 10.0
            logger.warning(
                'SetMetricState operation with the handle %s has no MaxTimeToFinish, using default of %d seconds',
                operation.Handle,
                timeout,
                extra={'step': step},
            )
        else:
            timeout = operation.MaxTimeToFinish
        with observables.bound_context(consumer.mdib, metrics_by_handle=observer):
            start = time.perf_counter()
            fut: Future[operations.OperationResult] = set_service.set_metric_state(operation.Handle, proposed_states)
            try:
                operation_result = fut.result(timeout)
            except TimeoutError:
                logger.exception(
                    'SetMetricState operation not finished within the timeout of %s seconds',
                    timeout,
                    extra={'step': step},
                )
                test_results.append(False)
                continue
            metric_timeout = timeout + 1 - (time.perf_counter() - start)
            metrics_updated = observer_event.wait(metric_timeout)
        if operation_result.set_response.InvocationInfo.InvocationState != msg_types.InvocationState.FINISHED:
            logger.error(
                'SetMetricState operation not immediately responded with %s but with invocation state '
                '%s and error %s: %s',
                msg_types.InvocationState.FINISHED,
                operation_result.set_response.InvocationInfo.InvocationState,
                operation_result.set_response.InvocationInfo.InvocationError,
                operation_result.set_response.InvocationInfo.InvocationErrorMessage,
                extra={'step': step},
            )
            test_results.append(False)
        else:
            logger.info(
                'SetMetricState operation immediately responded with %s as expected',
                msg_types.InvocationState.FINISHED,
                extra={'step': step},
            )
            test_results.append(True)
        if len(operation_result.report_parts) != 1:
            logger.error(
                'SetMetricState operation finished with %d report parts, but expected exactly 1',
                len(operation_result.report_parts),
                extra={'step': step},
            )
            test_results.append(False)
            continue
        if operation_result.InvocationInfo.InvocationState != msg_types.InvocationState.FINISHED:
            logger.error(
                'SetMetricState operation failed with invocation state %s and error %s: %s',
                operation_result.InvocationInfo.InvocationState,
                operation_result.InvocationInfo.InvocationError,
                operation_result.InvocationInfo.InvocationErrorMessage,
                extra={'step': step},
            )
            test_results.append(False)
            continue
        if not metrics_updated:
            missing_handles = sorted(set(expected_values_by_handle) - observed_handles)
            logger.error(
                'The Reference Provider did not report updated metric values for handles %s within %d seconds',
                missing_handles,
                metric_timeout,
                extra={'step': step},
            )
            test_results.append(False)
            continue
        logger.info(
            'SetMetricState operation finished immediately responds with Fin and updated the metric values '
            'accordingly.',
            extra={'step': step},
        )
        test_results.append(True)
    return any(test_results) and all(test_results)


def test_6f(consumer: SdcConsumer) -> bool:  # noqa: PLR0915
    """The Reference Provider invokes Activate:
    - Payload: 3 arguments
    - The Reference Provider immediately responds with Fin
    - Action: The Reference Provider accepts 3 arguments, concatenates them and writes them to the operation target's metric value
    """  # noqa: D205, D400, D415, E501, W505
    step = f'{__STEP__}f'
    test_results: list[bool] = []

    # TODO: iterate over operations  # noqa: FIX002, TD002, TD003
    string_argument = msg_types.Argument()
    string_argument.ArgValue = ''.join(random.choice(string.ascii_lowercase) for i in range(20))
    decimal_argument = msg_types.Argument()
    decimal_argument.ArgValue = str(random.randint(1, 2**20))
    any_uri_argument = msg_types.Argument()
    any_uri_argument.ArgValue = uuid.uuid4().urn
    arguments = [string_argument, decimal_argument, any_uri_argument]
    activate_operation_handle = 'activate_1.sco.mds_0'
    try:
        activate_operation: descriptorcontainers.ActivateOperationDescriptorContainer = (
            consumer.mdib.descriptions.handle.get_one(activate_operation_handle)
        )
    except KeyError:
        logger.error(  # noqa: TRY400
            'no operation with handle "%s" found in MDIB',
            activate_operation_handle,
            extra={'step': step},
        )
        return False
    expected_value = ''.join([argument.ArgValue for argument in arguments])
    observed = threading.Event()
    if activate_operation.MaxTimeToFinish is None:
        timeout = 10.0
        logger.warning(
            'Activate operation with the handle %s has no MaxTimeToFinish, using default of %d seconds',
            activate_operation.Handle,
            timeout,
            extra={'step': step},
        )
    else:
        timeout = activate_operation.MaxTimeToFinish

    def _observe_operation_metric_value(metrics_by_handle: dict):
        if activate_operation.OperationTarget in metrics_by_handle:
            state = metrics_by_handle[activate_operation.OperationTarget]
            logger.debug(
                'received an update for "%s" with value "%s"',
                activate_operation.OperationTarget,
                state.MetricValue,
                extra={'step': step},
            )
            if state.MetricValue is not None and state.MetricValue.Value == expected_value:
                observed.set()

    with observables.bound_context(consumer.mdib, metrics_by_handle=_observe_operation_metric_value):
        start = time.perf_counter()
        fut: Future = consumer.set_service_client.activate(activate_operation_handle, arguments)
        try:
            operation_result = fut.result(timeout)
        except TimeoutError:
            logger.exception(
                'Activate operation not finished within the timeout of %s seconds',
                timeout,
                extra={'step': step},
            )
            return False
        metric_timeout = timeout + 1 - (time.perf_counter() - start)
        if observed.wait(metric_timeout):
            logger.info(
                'The Reference Provider updated the metric with the handle %s to the expected value %s.',
                activate_operation.OperationTarget,
                expected_value,
                extra={'step': step},
            )
            test_results.append(True)
        else:
            logger.error(
                'The Reference Provider did not update the metric with the handle %s to the expected value %s '
                'within the timeout of %s seconds.',
                activate_operation.OperationTarget,
                expected_value,
                metric_timeout,
                extra={'step': step},
            )
            test_results.append(False)
    if operation_result.set_response.InvocationInfo.InvocationState != msg_types.InvocationState.FINISHED:
        logger.error(
            'Activate operation not immediately responded with %s but with invocation state %s and error %s: %s',
            msg_types.InvocationState.FINISHED,
            operation_result.set_response.InvocationInfo.InvocationState,
            operation_result.set_response.InvocationInfo.InvocationError,
            operation_result.set_response.InvocationInfo.InvocationErrorMessage,
            extra={'step': step},
        )
        test_results.append(False)
    else:
        logger.info(
            'Activate operation immediately responded with %s as expected',
            msg_types.InvocationState.FINISHED,
            extra={'step': step},
        )
        test_results.append(True)

    if operation_result.InvocationInfo.InvocationState in (msg_types.InvocationState.FINISHED,):
        logger.info(
            'The metric with the handle %s contains %s as @MetricValue/@Value.',
            activate_operation.OperationTarget,
            expected_value,
            extra={'step': step},
        )
        test_results.append(True)
    else:
        logger.error(
            'Activate operation failed with invocation state %s and error %s: %s',
            operation_result.InvocationInfo.InvocationState,
            operation_result.InvocationInfo.InvocationError,
            operation_result.InvocationInfo.InvocationErrorMessage,
            extra={'step': step},
        )
        test_results.append(False)
    return any(test_results) and all(test_results)
